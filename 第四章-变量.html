<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>第四章变量 variable</title>
</head>
<body>
<header>
    <h1>第四章-变量</h1>
</header>

<hr/>
<p><b>4.1 变量的类型</b></p>
<ul>
    <li>javascript变量可以存放任何类型的值</li>
    <li>必要时，javascript可以快速自动的将一种类型值转为另一种类型</li>
    <li>java C++变量只能存放所声明的特定类型的值</li>
    <li>java C++编写复杂、精确，javascript编写简短、灵活</li>
</ul>

<hr/>
<p><b>4.2 变量的声明</b></p>
<ul>
    <li>使用变量前，必须先声明，使用关键字var</li>
    <li>可以单独声明var a；var b；或一次性声明：var a，b</li>
    <li>声明和初始化一体化；var msg = "hello"，a=1，j=0；</li>
    <li>声明了变量，未赋值，赋值该变量前初始值为undefined</li>
    <li>作为for、in语句一部分</li>
    <li>使用delete运算符删除变量，会引发错误</li>
    <li>重复声明、遗漏声明
        <ul>
            <li>重复声明使用最新的赋值</li>
            <li>读未声明的变量，会生成错误，给未声明的变量赋值，会被隐式转换，当做全局变量</li>
            <li>防止在创建局部变量时，创建了全局变量，必须在函数体内使用var语句</li>
            <li>无论全局变量还是局部变量，最好使用var创建</li>
        </ul>
    </li>
</ul>

<hr/>
<p><b>4.3 变量的作用域（scope）</b></p>
<ul>
    <li>全局（global）变量的作用域是全局性的，处处有定义</li>
    <li>局部（local）变量，函数之内声明的变量，只在函数体内部有定义，作用是局部的</li>
    <li>函数的参数也是局部变量，只在函数体内有定义</li>
    <li>函数体内部，局部变量优先级高于同名的全局变量，如局部变量名称同于全局变量，则全局变量会被隐藏</li>
    <li>全局变量可以不使用var语句，但局部必须使用</li>
    <li>没有块级作用域</li>
    <li>
        <pre>
        <code style="color: #333333">
            var a ="hello";
            function f() {
                console.log(a);//输出undefied
                var a = "world";
                console.log(a);//输出 world
            }
        </code>
        </pre>
        <span>等价于</span>
        <pre>
        <code style="color: #333333">
            function f() {
                var a;
                console.log(a);//输出undefied
                var a = "world";
                console.log(a);//输出 world
            }
        </code>
        </pre>
    </li>
    <li>未定义的变量和未赋值的变量
        <ul>
            <li>读取未声明的变量会引起错误</li>
            <li>给未声明的变量赋值不会引起错误</li>
            <li>已经声明但未赋值的变量，会得到默认值undefined</li>
            <li>
                <pre>
                <code style="color: #333333">
                    var x;          //undefined
                    console.log(s)  //error
                    w = 3           //创建为全局变量
                </code>
                </pre>
            </li>
        </ul>
    </li>
</ul>

<hr/>
<p><b>4.3 基本类型和引用类型</b></p>
<ul>
    <li>基本类型：数值、布尔值、null、undefined</li>
    <li>引用类型：对象、数组、函数（长度任意，不固定）</li>
    <li>示例

        <pre>
            基本类型
                <code style="color: #333333">
                    var a =3.14;
                    var b = a;
                    a = 4;
                    console.log(b); //3.14
                </code>
        </pre>
        <pre>
            引用类型
                <code style="color: #333333">
                    var a = [1,2,3];
                    var b = a;
                    a[0] = 99;
                    console.log(b); //[99,2,3]
                </code>
        </pre>
    </li>
    <li>字符串具有可变大小，不能直接存储在具有固定大小的变量中</li>
</ul>

<hr/>
<p><b>4.5 无用存储单元收集（garbage collection）</b></p>
<ul>
    <li>无用的对象会被自动销毁</li>
</ul>

<hr/>
<p><b>4.6 作为属性的变量</b></p>
<ul>
    <li>全局对象（global object）
        <ul>
            <li>全局变量是特殊的全局对象的属性</li>
            <li>window对象代表浏览窗口，它是包含在该窗口中所有代码的全局对象，有自我引用window属性，代替了this</li>
            <li>window对象定义了全局的核心属性，如parseInt、Math，也定义了全局的客户端属性，如navigator、screen</li>
        </ul>
    </li>
    <li>局部变量
        <ul>
            <li>局部变量是调用对象的属性</li>
            <li>调用对象生命周期短于全局对象，用途同全局对象</li>
            <li>用完全独立的对象来存储局部变量，可以防止局部变量覆盖同名的全局变量的值</li>
        </ul>
    </li>
    <li>js执行环境（execution context）
        <ul>
            <li>所有js都运行在自己独有的执行环境中，且都有自己的调用对象，在调用对象中定义了局部变量</li>
            <li>js允许有多个全局执行环境，每个执行环境有不同的全局对象</li>
            <li>一个框架中的js可使用表达式parent.frames[1]来引用另一个框架中的js</li>
            <li>第二个框架中的代码使用表达式parent.frames[0].x，来引用第一个框架中的全局变量x</li>
            <li>安全性限制窗口数据访问；【重要】</li>
        </ul>
    </li>
</ul>

<hr/>
<p><b>4.7 变量作用域</b></p>
<ul>
    <li>全局变量具有全局的作用域，函数中声明的变量具有嵌套的局部作用域</li>
    <li>每个js执行环境都有一个和它关联一起的作用链（scope chain），这个作用链是一个对象列表或者对象链</li>
    <li>js查询变量x时，会查看该链的第一个对象，有就返回，无则继续。</li>
    <li>顶层代码中，作用域链只有一个对象构成，即为全局对象，所有变量都在此对象中查询</li>
    <li>在非嵌套函数中，作用域链是由两个对象构成，一个是函数的调用对象，一个是全局对象，</li>
    <li>函数引用变量时候，首先检查的是调用对象（局部作用域），其次才检查全局对象（全局作用域）</li>
    <li>嵌套函数中的作用域链可以有三个或更多的对象</li>
</ul>

</body>
</html>
